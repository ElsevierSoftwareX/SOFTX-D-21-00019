* DONE eliminare variabili globali
** come fare
- usando variabili statiche
- oppure passando parametri, definiti nel main (magari creare una struct network con tutti i nodi e i canali)
- vedi https://stackoverflow.com/questions/3208531/c-program-structure-avoiding-global-variables-includes-etc
** DONE creare struttura network da passare a funzioni 
- contiene anche faulty node probability
** DONE creare array payments da passare a funzioni
** DONE mettere riferimento a payment in event, anziche id del payment
** DONE creare struct simulation 
- contiene heap events, current time e  da passare a funzioni
* DONE input e output
** DONE configuration file per l'input
- file che definisce l'input, con coppie [is-preinput, 0], [channel-file, x.csv]
- fare formato json o csv
** DONE provare a rendere il sistema stazionario
il sistema simulato non e' stazionario, perche' il tempo medio di pagamento
aumenta di batch in batch. Questo e' dovuto al fatto che via via che si eseguono
pagamenti i canali si sbilanciano e i nuovi pagamenti prendono piu' tempo.
*** DONE partire da canali sbilanciati
ho provato a creare sin dall'inzio della simulazione canali sbilanciati. la
fraction di capacity e' un numero randomico uniforme tra 0 e 1, generando in
media un rapporto 0.2/0.8 di balance nei canali. 

Al termine della simulazione questo rapporto rimane quasi identico, cioe' i
canali in media non si sono sbilanciati durante la simulazione. Quindi e'
probabile che lo sbilanciamento sia una caratteristica intrinseca della
topologia (oltre che della capacita' dei canali e dei pagamenti simulati):i
pagamenti tendono tutti a fare gli stessi percorsi, per es. passando dallo
stesso nodo, e che i canali di questo nodo si sbilanciano.
*** DONE creare nuovi canali
creo un nuovo canale randomico ogni 100 ms. Anche in questo caso non e' cambiato
nulla
*** TODO fare altre prove

** DONE riscrivere  batch-means.py
- rimuovere il transitorio
- settare condizioni di fine della simulazione e dell'analisi dell'output
- usare i for per calcolare le varie misure
* DONE organizzare i file
** DONE modifica path dei file della topologia in initialize_topology_preproc
** DONE fare due cartelle: src, include
** DONE fare file cloth.c con main e altri oggetti del similatore (i/o,random generator)
** DONE fare file network.c dove ci sono i vari create_channel create_node
** DONE fare file payment.c
** DONE il file protocol.c diventa htlc.c
- cosi quando si vuole aggiungere nuovo protocollo si crea file separato new-protoco.c
** DONE global.h eliminato: i thread vanno in routing.h
** DONE routing.c
*** DONE spostare qui thread
*** DONE elimina dijkstra_p, che diventa dijkstra (i non-thread lo chiamano con indice 0)
* DONE creazione random network
- usa algoritmo descritto qui https://medium.com/blockstream/letting-a-million-channels-bloom-985bdb28660b
* DONE cambio nomi variabili
** DONE camel case to snake case
** DONE channelInfo -> channel, channel->edge
*** DONE tipi
*** DONE nomi variabili
- provare con
 sed -i 's/channel/edge/g' main.c global.h simulator/* protocol/* utils/*
 sed -i 's/edge_info/channel/g' main.c global.h simulator/* protocol/* utils/*
** DONE peer->node, Node -> elemento della lista
** DONE togliere typedef e lasciare struct x
** DONE cambiare nomi campi in struct
* TODO aggiornare a lnd-0.9 (0.10 con MPP)
** DONE find route and send payment
*** DONE new dijsktra
*** DONE get policy
*** DONE edge probabilities (`applypaymentresult`)
*** DONE fixed final timelock
** DONE forward payment
- the hop must check all his edges connecting to the next node and selects the
  first for which the policies are respect (if any).
- non-strict forwarding: A node MAY forward an HTLC along an outgoing channel
  other than the one specified by short_channel_id, so long as the receiver has
  the same node public key intended by short_channel_id. Thus, if
  short_channel_id connects nodes A and B, the HTLC can be forwarded across any
  channel connecting A and B [https://github.com/lightningnetwork/lightning-rfc/blob/master/04-onion-routing.md#non-strict-forwarding]
** DONE receive payment result
- update the results of the payment for each edge and node (see `applyPaymentResult`)
** TODO MPP 
* TODO lanciare sonarcube
* TODO test
* TODO altro
** DONE la capacity in input e' da esprimere in satoshi (poi nella funzione si moltiplica per 1000 per convertire in millisat)
** DONE latency non come attributo di channel ma come numero randomico
** TODO exit(-1) in tutte le condizioni di errore (per es. in check_policy_forward)
- fai search di parola chiave "ERROR"
** DONE rimuovere withholds R
** DONE rimuovere gini
- oppure rifare in modo che non bisogna specificare i fondi *3
** TODO ripensare a sigma_amount
** DONE ripensare a uncoop_after_HTLC
** TODO cancellare funzioni non utilizzate e commentate
* librerie in anguirel
- installa gsl in /usr/include, installandolo da riga di comando
- rimuovi ogni riferimento a jsonc etc. 


