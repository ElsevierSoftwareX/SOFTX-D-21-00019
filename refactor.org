* DONE eliminare variabili globali
** come fare
- usando variabili statiche
- oppure passando parametri, definiti nel main (magari creare una struct network con tutti i nodi e i canali)
- vedi https://stackoverflow.com/questions/3208531/c-program-structure-avoiding-global-variables-includes-etc
** DONE creare struttura network da passare a funzioni 
- contiene anche faulty node probability
** DONE creare array payments da passare a funzioni
** DONE mettere riferimento a payment in event, anziche id del payment
** DONE creare struct simulation 
- contiene heap events, current time e  da passare a funzioni
* TODO input e output
** DONE configuration file per l'input
- file che definisce l'input, con coppie [is-preinput, 0], [channel-file, x.csv]
- fare formato json o csv
** TODO riscrivere  batch-means.py
- rimuovere il transitorio
- settare condizioni di fine della simulazione e dell'analisi dell'output
- usare i for per calcolare le varie misure
* DONE organizzare i file
** DONE modifica path dei file della topologia in initialize_topology_preproc
** DONE fare due cartelle: src, include
** DONE fare file cloth.c con main e altri oggetti del similatore (i/o,random generator)
** DONE fare file network.c dove ci sono i vari create_channel create_node
** DONE fare file payment.c
** DONE il file protocol.c diventa htlc.c
- cosi quando si vuole aggiungere nuovo protocollo si crea file separato new-protoco.c
** DONE global.h eliminato: i thread vanno in routing.h
** DONE routing.c
*** DONE spostare qui thread
*** DONE elimina dijkstra_p, che diventa dijkstra (i non-thread lo chiamano con indice 0)
* DONE connessione nodi
- usa algoritmo descritto qui https://medium.com/blockstream/letting-a-million-channels-bloom-985bdb28660b
* DONE cambio nomi variabili
** DONE camel case to snake case
** DONE channelInfo -> channel, channel->edge
*** DONE tipi
*** DONE nomi variabili
- provare con
 sed -i 's/channel/edge/g' main.c global.h simulator/* protocol/* utils/*
 sed -i 's/edge_info/channel/g' main.c global.h simulator/* protocol/* utils/*
** DONE peer->node, Node -> elemento della lista
** DONE togliere typedef e lasciare struct x
** DONE cambiare nomi campi in struct
* TODO provare a rendere il sistema stazionario
il sistema simulato non e' stazionario, perche' il tempo medio di pagamento
aumenta di batch in batch. Questo e' dovuto al fatto che via via che si eseguono
pagamenti i canali si sbilanciano e i nuovi pagamenti prendono piu' tempo.
** DONE partire da canali sbilanciati
ho provato a creare sin dall'inzio della simulazione canali sbilanciati. la
fraction di capacity e' un numero randomico uniforme tra 0 e 1, generando in
media un rapporto 0.2/0.8 di balance nei canali. 

Al termine della simulazione questo rapporto rimane quasi identico, cioe' i
canali in media non si sono sbilanciati durante la simulazione. Quindi e'
probabile che lo sbilanciamento sia una caratteristica intrinseca della
topologia (oltre che della capacita' dei canali e dei pagamenti simulati):i
pagamenti tendono tutti a fare gli stessi percorsi, per es. passando dallo
stesso nodo, e che i canali di questo nodo si sbilanciano.
** DONE creare nuovi canali
creo un nuovo canale randomico ogni 100 ms. Anche in questo caso non e' cambiato
nulla
** TODO fare altre prove
* TODO aggiornare a lnd-0.9 (0.10 con MPP)
** find route and send payment
- default finalcltv timelock delta is 40 blocks. this must be the timelock in
  the last edge
- in dijkstra, return error when the maximum of balances the sender edges is
  lower than the payment amount (without fees)
- fees are computed in this way:
	return c.FeeBaseMSat + (amt*c.FeeProportionalMillionths)/1e6
- stop dijkstra when timelock limit is exceeded. Default timelock limit is
  2016+40.
- implement dijkstra with the probabilty
- implement `getPolicy` to take the policy used in dijkstra
** forward payment
- the hop must check all his edges connecting to the next node and selects the
  first for which the policies are respect (if any).
** receive payment result
- update the results of the payment for each edge and node (see `applyPaymentResult`)
** MPP 
* TODO lanciare sonarcube
* TODO test
* TODO altro
** DONE la capacity in input e' da esprimere in satoshi (poi nella funzione si moltiplica per 1000 per convertire in millisat)
** DONE latency non come attributo di channel ma come numero randomico
** TODO exit(-1) in tutte le condizioni di errore (per es. in check_policy_forward)
- fai search di parola chiave "ERROR"
** DONE rimuovere withholds R
** DONE rimuovere gini
- oppure rifare in modo che non bisogna specificare i fondi *3
** TODO ripensare a sigma_amount
** DONE ripensare a uncoop_after_HTLC
** TODO cancellare funzioni non utilizzate e commentate
* librerie in anguirel
- installa gsl in /usr/include, installandolo da riga di comando
- rimuovi ogni riferimento a jsonc etc. 
